    // BEGIN player-history-state
    const playerHistory=[];
    // END player-history-state
    function addPlayer(){const name=playerInput.value.trim();if(name&&players.length<30){players.push(name);
    // BEGIN player-history-sync-on-add
    trimPlayerHistory();
    // END player-history-sync-on-add
    renderPlayerList();playerInput.value="";playerInput.focus();}}
    function removePlayer(i){players.splice(i,1);
    // BEGIN player-history-sync-on-remove
    trimPlayerHistory();
    // END player-history-sync-on-remove
    renderPlayerList();}
    // BEGIN player-history-helpers
    function getPlayerHistoryLimit(){return Math.max(0,Math.ceil(players.length*0.5));}
    function trimPlayerHistory(){for(let i=playerHistory.length-1;i>=0;i--){if(!players.includes(playerHistory[i])){playerHistory.splice(i,1);}}const limit=getPlayerHistoryLimit();while(playerHistory.length>limit){playerHistory.shift();}}
    function rememberPlayerSelection(name){if(!name){return;}playerHistory.push(name);trimPlayerHistory();}
    function pickPlayerWithHistory(exclusions=[],options={}){if(!players.length){return null;}const opts=options&&typeof options==="object"?options:{};const register=opts.register!==false;const excludeList=Array.isArray(exclusions)?exclusions.filter(Boolean):[exclusions].filter(Boolean);trimPlayerHistory();const limit=getPlayerHistoryLimit();const recentEntries=limit>0?playerHistory.slice(-limit):[];const combinedSet=new Set([...recentEntries,...excludeList]);let candidates=players.filter(name=>!combinedSet.has(name));if(!candidates.length){const excludeSet=new Set(excludeList);candidates=players.filter(name=>!excludeSet.has(name));}const chosen=candidates.length?candidates[Math.floor(Math.random()*candidates.length)]:null;if(chosen&&register){rememberPlayerSelection(chosen);}return chosen;}
    // END player-history-helpers

        // BEGIN player-history-culture-selection
        let player=pickPlayerWithHistory();
        if(!player&&players.length){player=players[Math.floor(Math.random()*players.length)];rememberPlayerSelection(player);}
        if(!player){return;}
        // END player-history-culture-selection
      else if(mode==="debut"||mode==="hardcore"||mode==="alcool"){const pool={debut:debutQuestions,hardcore:hardcoreQuestions,alcool:alcoolQuestions}[mode];const [type,text]=pool[Math.floor(Math.random()*pool.length)].split("|");
      // BEGIN player-history-primary-selection
      let player=pickPlayerWithHistory();
      if(!player&&players.length){player=players[Math.floor(Math.random()*players.length)];rememberPlayerSelection(player);}
      let qText=text.replace(/\{player\}/g,player||"");
      // END player-history-primary-selection
      let other=null;
      if(qText.includes("{other}")){
      // BEGIN player-history-secondary-selection
      other=pickPlayerWithHistory([player],{register:false});
      if((!other||other===player)&&players.length>1){const fallback=players.filter(p=>p!==player);if(fallback.length){other=fallback[Math.floor(Math.random()*fallback.length)];}}
      if(!other){other=player;}
      qText=qText.replace(/\{other\}/g,other||"");
      // END player-history-secondary-selection
      }
      if(qText.includes("{random_player}")){
      // BEGIN player-history-random-placeholder
      const exclusions=[player];if(other&&other!==player){exclusions.push(other);}let randomParticipant=pickPlayerWithHistory(exclusions,{register:false});if((!randomParticipant||exclusions.includes(randomParticipant))&&players.length>1){const fallback=players.filter(p=>!exclusions.includes(p));if(fallback.length){randomParticipant=fallback[Math.floor(Math.random()*fallback.length)];}}
      if(!randomParticipant){randomParticipant=player;}
      qText=qText.replace(/\{random_player\}/g,randomParticipant||"");
      // END player-history-random-placeholder
      }
      typeBox.textContent=type;setBackground(type);currentQuestionEl.textContent=qText;}}
